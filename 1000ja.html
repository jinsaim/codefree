<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>천자문 연습</title>
	<style>
		:root {
			--bg: #0f172a; /* slate-900 */
			--panel: #111827; /* gray-900 */
			--muted: #94a3b8; /* slate-400 */
			--text: #e5e7eb; /* gray-200 */
			--accent: #22c55e; /* green-500 */
			--accent-2: #60a5fa; /* blue-400 */
			--danger: #f43f5e; /* rose-500 */
			--warn: #f59e0b; /* amber-500 */
		}
		* { box-sizing: border-box; }
		body { margin: 0; background: linear-gradient(120deg, #0b1020, #111a2f); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, sans-serif; }
		header { padding: 1rem 1.25rem; border-bottom: 1px solid #1f2937; position: sticky; top: 0; background: rgba(17,24,39,0.8); backdrop-filter: blur(6px); }
		header h1 { margin: 0; font-size: 1.125rem; }
		.container { max-width: 980px; margin: 0 auto; padding: 1rem 1.25rem; }
		.toolbar { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; }
		.toolbar select, .toolbar button, .toolbar input[type="text"] { background: #0b1220; color: var(--text); border: 1px solid #1f2937; padding: .5rem .75rem; border-radius: .5rem; }
		.toolbar button { cursor: pointer; }
		.toolbar button.primary { background: var(--accent); color: #052e13; border-color: transparent; font-weight: 600; }
		.toolbar label.lbl { color: var(--muted); font-size: .9rem; margin-left: .25rem; }
		.grid { display: grid; grid-template-columns: repeat(8, minmax(0, 1fr)); gap: .75rem; margin-top: 1rem; }
		/* Switch to block list when rendering per-row layout */
		.grid.rows-mode { display: block; }
		/* Numeric group selected -> 4 columns per row */
		.grid.cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
		/* Row of 4 cards + explanation to the right */
	/* 4 cards take 1/3 width, explanation 2/3 */
	.quad-row { display: grid; grid-template-columns: 1fr 2fr; gap: .75rem; align-items: stretch; margin-bottom: .75rem; }
	.quad-row .cards-wrap { display: grid; grid-template-columns: repeat(4, 1fr); gap: .75rem; }
		.row-explain { background: #0b1220; border: 1px dashed #334155; color: var(--muted); border-radius: .5rem; padding: .6rem .7rem; font-size: .9rem; line-height: 1.5; }
	@media (max-width: 640px) { .quad-row { grid-template-columns: 1fr; } .row-explain { grid-column: 1 / -1; } }
		.card { background: #0b1220; border: 1px solid #1f2937; border-radius: .75rem; padding: .75rem; text-align: center; transition: transform .12s ease, border-color .12s ease; }
		.card:hover { transform: translateY(-2px); border-color: #334155; }
		.hanja { font-size: 28px; line-height: 1.2; }
		.hangeul { font-size: 12px; color: var(--muted); margin-top: .25rem; }
		.meta { margin-top: .35rem; font-size: 11px; color: #a1a1aa; }
		.mode { display: none; }
		.mode.active { display: block; }
		.panel { background: #0b1220; border: 1px solid #1f2937; border-radius: .75rem; padding: 1rem; margin-top: 1rem; }
		.row { display: grid; grid-template-columns: 1fr 1fr; gap: .75rem; align-items: center; }
		.row input, .row textarea { width: 100%; background: #0b1020; border: 1px solid #1f2937; color: var(--text); border-radius: .5rem; padding: .6rem .7rem; }
		.row label { font-size: .9rem; color: var(--muted); }
		.quiz { text-align: center; }
		.quiz .question { font-size: 36px; margin: .75rem 0; }
		.quiz .hint { color: var(--muted); font-size: .95rem; }
		.quiz input { margin-top: .5rem; font-size: 1rem; }
		.quiz .result { margin-top: .75rem; font-weight: 600; }
		.ok { color: var(--accent); }
		.bad { color: var(--danger); }
		.footer { color: var(--muted); font-size: .85rem; margin-top: 1rem; text-align: right; }

		/* Tips panel */
		.tips { margin-top: .75rem; }
		.tips-box { background: #0b1220; border: 1px dashed #334155; color: var(--muted); border-radius: .5rem; padding: .6rem .7rem; font-size: .9rem; line-height: .95; }
		.tips-box ul { margin: .25rem 0 0; padding-left: 1.1rem; }
		.tips-box li { margin: .15rem 0; }

		/* Explanation editor */
		.explain-view { white-space: pre-wrap; word-break: break-word; }
	.explain-input { width: 100%; height: 36px; margin-top: .35rem; background: #0b1020; color: var(--text); border: 1px solid #1f2937; border-radius: .5rem; padding: .35rem .5rem; display: none; }
	.explain-actions { display: flex; gap: .35rem; margin-top: .4rem; }
	.explain-actions .btn { padding: .35rem .55rem; font-size: .85rem; }
		.saved-badge { color: #22c55e; font-size: .8rem; margin-left: .25rem; display: none; }

		/* Stroke-order modal */
		.modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 50; }
		.modal.show { display: flex; }
		.modal-content { width: min(92vw, 420px); background: #0b1220; border: 1px solid #1f2937; border-radius: 12px; box-shadow: 0 20px 60px rgba(0,0,0,0.35); }
		.modal-header { display: flex; align-items: center; justify-content: space-between; padding: .9rem 1rem; border-bottom: 1px solid #1f2937; }
		.modal-title { font-weight: 700; }
		.modal-body { padding: 1rem; display: grid; gap: .5rem; justify-items: center; }
		#strokeTarget { width: 280px; height: 280px; background: #0b1020; border: 1px dashed #334155; border-radius: .75rem; display: grid; place-items: center; }
		.modal-footer { padding: .9rem 1rem; display: flex; gap: .5rem; justify-content: flex-end; border-top: 1px solid #1f2937; }
		.btn { background: #0b1220; color: var(--text); border: 1px solid #334155; padding: .5rem .8rem; border-radius: .5rem; cursor: pointer; }
		.btn:hover { border-color: #475569; }
		.btn.primary { background: var(--accent); color: #052e13; border-color: transparent; font-weight: 700; }

		/* bulk paste removed */
	</style>
	<script src="https://cdn.jsdelivr.net/npm/hanzi-writer@2.2/dist/hanzi-writer.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
	<header>
		<h1>천자문 연습 · 1000字</h1>
	</header>
	<div class="container">
		<div class="toolbar">
			<select id="modeSelect" title="모드 선택">
				<option value="learn">학습</option>
				<option value="quiz">퀴즈</option>
				<option value="write">쓰기</option>
			</select>
			<input type="text" id="search" placeholder="검색(한자/음/뜻)" />
			<label for="groupFilter" class="lbl">묶음:</label>
			<select id="groupFilter" title="묶음 선택">
				<option value="">전체 묶음</option>
			</select>
			<button id="resetBtn">초기화</button>
			<button id="exportBtn">백업</button>
			<button id="viewJsonBtn">JSON 보기</button>
			<input id="importFile" type="file" accept=".json,.xlsx,.xls,.csv,application/json,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel,text/csv" style="display:none" />
			<button id="importBtn">가져오기</button>
			<span class="footer" id="countInfo"></span>
		</div>
		<div class="tips">
			<div class="tips-box" role="note" aria-label="사용 안내">
				<ul>
					<li>묶음 숫자는 한자를 4자씩 보게 해줘요.</li>
					<li>한자 카드를 클릭하면 필순을 볼 수 있어요.</li>
				</ul>
			</div>
		</div>

		<!-- 학습 모드 -->
		<section id="mode-learn" class="mode active">
			<div class="grid" id="learnGrid"></div>
		</section>

		<!-- 퀴즈 모드 -->
		<section id="mode-quiz" class="mode">
			<div class="panel quiz">
				<div class="hint">한자를 보고 뜻과 음(예: 하늘 천)을 쓰세요</div>
				<div class="question" id="quizQuestion">天</div>
				<input id="quizAnswer" type="text" placeholder="정답 입력" />
				<div>
					<button id="quizCheck" class="primary">정답 확인</button>
					<button id="quizNext">다음</button>
				</div>
				<div class="result" id="quizResult"></div>
			</div>
		</section>

		<!-- 쓰기 모드 -->
		<section id="mode-write" class="mode">
			<!-- Handwriting practice within current group -->
			<div class="panel" id="practicePanel">
				<div style="display:flex; justify-content:space-between; align-items:center; gap:.75rem; flex-wrap:wrap;">
					<div id="pRead" style="color: var(--muted); font-size:1rem;">천 / 하늘</div>
					<div class="practice-controls" style="display:flex; gap:.5rem;">
						<button id="pPrev">이전</button>
						<button id="pNext">다음</button>
						<button id="pStart" class="primary">쓰기 연습</button>
						<button id="pReset">초기화</button>
						<button id="pShow">다시 확인</button>
					</div>
				</div>
				<div id="practiceTarget" style="width:320px;height:320px;margin:.75rem auto; background:#ffffff; border:1px solid #e5e7eb; border-radius:.75rem;"></div>
				<div id="pHint" class="hint" style="text-align:center; color:var(--muted);">음/훈만 보고 흰 바탕에서 바로 써 보세요.</div>
			</div>
		</section>

	</div>

		<!-- Stroke-order Modal -->
		<div id="strokeModal" class="modal" aria-hidden="true">
			<div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="strokeTitle">
				<div class="modal-header">
					<div class="modal-title" id="strokeTitle">필순 보기</div>
					<button id="strokeClose" class="btn" aria-label="닫기">닫기</button>
				</div>
				<div class="modal-body">
					<div id="strokeTarget"></div>
					<div id="strokeMeta" style="color: var(--muted); font-size: .9rem;"></div>
				</div>
				<div class="modal-footer">
					<button id="strokeReplay" class="btn primary">다시 보기</button>
				</div>
			</div>
		</div>

			<!-- bulk paste modal removed -->

	<script>
		// 기본 데이터(시드). 이후 JSON으로 전체를 불러올 수 있음
		const seed = [
			{ ch: '天', read: '천', mean: '하늘', group: '001' },
			{ ch: '地', read: '지', mean: '땅', group: '001' },
			{ ch: '玄', read: '현', mean: '검다, 오묘하다', group: '001' },
			{ ch: '黃', read: '황', mean: '누르다', group: '001' },
			{ ch: '宇', read: '우', mean: '집, 공간', group: '002' },
			{ ch: '宙', read: '주', mean: '시간, 시공', group: '002' },
			{ ch: '洪', read: '홍', mean: '크다', group: '002' },
			{ ch: '荒', read: '황', mean: '거칠다', group: '002' },
		];

		const LS_KEY = 'thousandChars_v1';
		const LS_LAST_IMPORT_KEY = 'thousandChars_lastImport';
		let data = [];

		async function loadData() {
			// 1) Try localStorage first
			try {
				const raw = localStorage.getItem(LS_KEY);
				if (raw) { data = JSON.parse(raw); return; }
			} catch (e) {
				console.warn('localStorage 읽기 실패', e);
			}
			// 2) If no local data, try fetching the bundled dataset
			try {
				const res = await fetch('thousandChars_v1.json', { cache: 'no-store' });
				if (res && res.ok) {
					const json = await res.json();
					const items = Array.isArray(json) ? json : (json.items || json.data || []);
					if (Array.isArray(items) && items.length) {
						data = items.map(x => ({
							ch: x.ch || x.char || x.hanja,
							read: x.read || x.kor || x.ko || '',
							mean: x.mean || x.desc || '',
							group: x.group || x.grp || 'import',
						}))
						.filter(x => x.ch);
						// Save as the current dataset for subsequent visits
						try { localStorage.setItem(LS_KEY, JSON.stringify(data)); } catch {}
						try { localStorage.setItem(LS_LAST_IMPORT_KEY, JSON.stringify(data)); } catch {}
						return;
					}
				}
			} catch (e) {
				console.warn('외부 데이터 로드 실패', e);
			}
			// 3) Fallback to seed
			data = seed;
		}

		function saveData() { try { localStorage.setItem(LS_KEY, JSON.stringify(data)); } catch (e) { console.warn('저장 실패', e); } }

		// Normalize compatibility ideographs to unified forms for HanziWriter
		function normalizeHanChar(ch){
			if (!ch) return ch;
			try {
				const nfkc = ch.normalize ? ch.normalize('NFKC') : ch;
				// Explicit mappings for common Korean compatibility forms
				const map = {
					'\uF961': '\u7387', // 率 -> 率
					'\uF978': '\u5F8B', // 律 -> 律
				};
				return map[nfkc] ? map[nfkc] : nfkc;
			} catch {
				return ch;
			}
		}

		// 부수 보완용 메타(라벨) 맵: 부족한 글자라도 레이블은 보여줌
		// kangxi: 강희 부수 번호, radical: 부수 글자, name: 한국식 명칭
		const radicalMetaMap = {
			'律': { kangxi: 60, radical: '彳', name: '두인변' },
			'率': { kangxi: 95, radical: '玄', name: '현' },
			'洪': { kangxi: 85, radical: '氵', name: '삼수변' },
			'荒': { kangxi: 140, radical: '艹', name: '초두머리' },
			// 필요 시 계속 보강 가능
		};
		function getRadicalMeta(ch) {
			return radicalMetaMap[ch] || null;
		}

		// 부수 색 분리를 위한 radStrokes 보강 맵(선택)
		// 특정 글자의 radStrokes 인덱스를 아시는 경우 여기에 등록하면 색 분리까지 가능
		// 예) '律': [0,1,2]  // 예시(실제 인덱스는 글자 데이터에 따라 다름)
		const radicalStrokeIndices = {
			// '律': [/* stroke indexes for radical */],
			// '率': [/* ... */],
		};

		// Hanzi Writer용 charData를 CDN에서 받아와 결손(radStrokes) 시 보강
		async function fetchCharData(ch) {
			const url = `https://cdn.jsdelivr.net/npm/hanzi-writer-data@2.0/${encodeURIComponent(ch)}.json`;
			const res = await fetch(url);
			if (!res.ok) throw new Error('charData fetch failed');
			const d = await res.json();
			if ((!d.radStrokes || d.radStrokes.length === 0) && radicalStrokeIndices[ch]) {
				d.radStrokes = radicalStrokeIndices[ch];
			}
			return d;
		}

		function setMode(mode) {
			document.querySelectorAll('.mode').forEach(el => el.classList.remove('active'));
			document.getElementById('mode-' + mode).classList.add('active');
		}

		function renderLearn(list) {
			const el = document.getElementById('learnGrid');
			const currentList = (list || data);
			const grpVal = (document.getElementById('groupFilter')?.value || '').trim();
			const queryVal = (document.getElementById('search')?.value || '').trim();
			const matchNum = grpVal.match(/^0*(\d+)$/);

			// If numeric group selected and no query, render rows of 4 + editable explanation
			if (matchNum && !queryVal) {
				// Load saved explanations per group
				const explainMap = (() => {
					try { return JSON.parse(localStorage.getItem('thousandChars_explain') || '{}'); } catch { return {}; }
				})();
				// Build map group -> items
				const byGroup = new Map();
				currentList.forEach((x) => {
					const g = x.group || '';
					if (!byGroup.has(g)) byGroup.set(g, []);
					byGroup.get(g).push(x);
				});
				// Sort groups numerically ascending
				const groupKeys = Array.from(byGroup.keys()).sort((a, b) => Number(a) - Number(b));
				// Compose rows
				const rowsHtml = groupKeys.map(g => {
					const items = byGroup.get(g).slice(0, 4); // ensure 4 max
					const cards = items.map(it => {
						const idxGlobal = data.indexOf(it);
						const hint = [it.mean || '', it.read || ''].filter(Boolean).join(' ');
						return `
						<div class="card" data-idx="${idxGlobal}">
							<div class="hanja">${it.ch}</div>
							<div class="hangeul">${hint}</div>
						</div>`;
					}).join('');
					const key = String(g);
					const saved = explainMap[key] || '';
					return `
					<div class="quad-row">
						<div class="cards-wrap">${cards}</div>
						<div class="row-explain" data-group="${key}">
							<div class="explain-view">${saved ? saved.replace(/</g,'&lt;').replace(/>/g,'&gt;') : ''}</div>
							<input type="text" class="explain-input" placeholder="4글자의 뜻을 풀어서 입력하세요" />
							<div class="explain-actions">
								<button class="btn" data-action="edit">풀이 쓰기</button>
								<button class="btn primary" data-action="save">저장</button>
								<span class="saved-badge">저장됨</span>
							</div>
						</div>
					</div>`;
				}).join('');
				el.innerHTML = rowsHtml;
				document.getElementById('countInfo').textContent = `${currentList.length}자`;
				// Wire explanation edit/save
				el.querySelectorAll('.row-explain').forEach(box => {
					const key = box.getAttribute('data-group');
					const view = box.querySelector('.explain-view');
					const input = box.querySelector('.explain-input');
					const savedBadge = box.querySelector('.saved-badge');
					const btnEdit = box.querySelector('[data-action="edit"]');
					const btnSave = box.querySelector('[data-action="save"]');
					btnEdit.addEventListener('click', () => {
						input.value = view.textContent || '';
						view.style.display = 'none';
						input.style.display = 'block';
						input.focus();
						savedBadge.style.display = 'none';
					});
					btnSave.addEventListener('click', () => {
						const map = (() => { try { return JSON.parse(localStorage.getItem('thousandChars_explain') || '{}'); } catch { return {}; }})();
						map[key] = input.value.trim();
						try { localStorage.setItem('thousandChars_explain', JSON.stringify(map)); } catch {}
						view.textContent = map[key] || '';
						input.style.display = 'none';
						view.style.display = '';
						savedBadge.style.display = 'inline';
						setTimeout(() => { savedBadge.style.display = 'none'; }, 1500);
					});
				});
				return;
			}

			// Default: flat card grid
			el.innerHTML = currentList.map((x) => {
				const idxGlobal = data.indexOf(x);
				const hint = [x.mean || '', x.read || ''].filter(Boolean).join(' ');
				return `
				<div class="card" data-idx="${idxGlobal}">
					<div class="hanja">${x.ch}</div>
					<div class="hangeul">${hint}</div>
				</div>`;
			}).join('');
			document.getElementById('countInfo').textContent = `${currentList.length}자`;
		}

		function shuffle(arr) {
			const a = [...arr];
			for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; }
			return a;
		}

		// 검색 + 그룹 필터
		function doSearch() {
			const q = document.getElementById('search').value.trim();
			const grp = document.getElementById('groupFilter').value;
			const learnGridEl = document.getElementById('learnGrid');
			let list = data;

			// Helper: parse numeric group like '001' -> 1; non-numeric returns null
			const parseGroupNum = (g) => {
				const m = String(g || '').match(/^0*(\d+)$/);
				return m ? parseInt(m[1], 10) : null;
			};

			const selectedNum = parseGroupNum(grp);
			if (selectedNum !== null) {
				// Cumulative: include all items with numeric group <= selected
				list = list.filter(x => {
					const gx = parseGroupNum(x.group);
					return gx !== null && gx <= selectedNum;
				});
				// Use rows-mode to render per-group rows with explanations
				if (!q) {
					learnGridEl.classList.add('rows-mode');
				} else {
					learnGridEl.classList.remove('rows-mode');
				}
			} else {
				// Equality filter for non-numeric groups (e.g., 'custom')
				if (grp) list = list.filter(x => (x.group || '') === grp);
				// Back to default grid
				learnGridEl.classList.remove('rows-mode');
			}

			if (q) {
				const re = new RegExp(q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
				list = list.filter(x => re.test(x.ch) || re.test(x.read) || re.test(x.mean || ''));
			}
			renderLearn(list);
		}

		function rebuildGroupFilter() {
			const sel = document.getElementById('groupFilter');
			const current = sel.value;
			const groups = Array.from(new Set(data.map(x => x.group).filter(Boolean))).sort();
			sel.innerHTML = '<option value="">전체 묶음</option>' + groups.map(g => `<option value="${g}">${g}</option>`).join('');
			if (current && groups.includes(current)) sel.value = current;
		}

		// Practice (handwriting) helpers
		let practiceList = [];
		let practiceIdx = 0;
		let practiceWriter = null;
		let practiceHistory = [];
		// Initialize a freehand drawing canvas inside #practiceTarget
		function initFreehandCanvas(){
			const target = document.getElementById('practiceTarget');
			target.innerHTML = '';
			const size = 320;
			const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
			const canvas = document.createElement('canvas');
			canvas.style.width = size + 'px';
			canvas.style.height = size + 'px';
			canvas.width = size * dpr;
			canvas.height = size * dpr;
			target.appendChild(canvas);
			const ctx = canvas.getContext('2d');
			ctx.scale(dpr, dpr);
			ctx.lineWidth = 3;
			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';
			ctx.strokeStyle = '#111827'; // dark ink on white
			let drawing = false;
			let lastX = 0, lastY = 0;
			const getPos = (e) => {
				const rect = canvas.getBoundingClientRect();
				const x = (e.clientX - rect.left);
				const y = (e.clientY - rect.top);
				return { x, y };
			};
			canvas.addEventListener('pointerdown', (e) => {
				canvas.setPointerCapture(e.pointerId);
				e.preventDefault();
				const p = getPos(e);
				drawing = true;
				lastX = p.x; lastY = p.y;
				ctx.beginPath();
				ctx.moveTo(lastX, lastY);
			});
			canvas.addEventListener('pointermove', (e) => {
				if (!drawing) return;
				e.preventDefault();
				const p = getPos(e);
				ctx.lineTo(p.x, p.y);
				ctx.stroke();
				lastX = p.x; lastY = p.y;
			});
			const endDraw = (e) => { if (!drawing) return; e.preventDefault(); drawing = false; };
			canvas.addEventListener('pointerup', endDraw);
			canvas.addEventListener('pointercancel', endDraw);
			canvas.addEventListener('pointerleave', endDraw);
		}
		function buildPracticeList(){
			const grp = document.getElementById('groupFilter').value;
			// Match quiz-mode behavior: numeric group = cumulative, else exact group, empty = all
			const m = String(grp || '').match(/^0*(\d+)$/);
			if (m) {
				const upTo = parseInt(m[1], 10);
				practiceList = data.filter(x => {
					const mm = String(x.group || '').match(/^0*(\d+)$/);
					return mm && parseInt(mm[1], 10) <= upTo;
				});
			} else if (grp) {
				practiceList = data.filter(x => (x.group || '') === grp);
			} else {
				practiceList = data.slice();
			}
			// Initialize a random starting index and history
			practiceHistory = [];
			setPracticeIdxRandom(true);
		}

		function setPracticeIdxRandom(pushHistory){
			if (!practiceList.length) { practiceIdx = 0; updatePracticeUI(); return; }
			let newIdx = practiceIdx;
			if (practiceList.length === 1) {
				newIdx = 0;
			} else {
				// Avoid immediate repetition if possible
				do { newIdx = Math.floor(Math.random() * practiceList.length); }
				while (newIdx === practiceIdx);
			}
			practiceIdx = newIdx;
			if (pushHistory) practiceHistory.push(practiceIdx);
			updatePracticeUI();
		}

		function updatePracticeUI(){
			const cur = practiceList[practiceIdx % Math.max(practiceList.length,1)];
			document.getElementById('pRead').textContent = cur ? [cur.mean || '', cur.read || ''].filter(Boolean).join(' ') : '';
			// Reset view to freehand canvas (pre-practice)
			practiceWriter = null;
			initFreehandCanvas();
		}

		async function startPractice(){
			const cur = practiceList[practiceIdx % Math.max(practiceList.length,1)];
			if (!cur) return;
			const target = document.getElementById('practiceTarget');
			target.innerHTML = '';
			const baseCh = normalizeHanChar(cur.ch);
			let opts = { width: 320, height: 320, padding: 12, showCharacter: false,
				strokeColor: '#22c55e', radicalColor: '#ef4444',
				strokeAnimationSpeed: 1.1, delayBetweenStrokes: 150 };
			try {
				const cd = await fetchCharData(baseCh);
				opts = { ...opts, charData: cd };
			} catch {}
			practiceWriter = HanziWriter.create(target, baseCh, opts);
			practiceWriter.quiz({
				showHintAfterMisses: 2,
				onComplete: () => { /* optional: toast */ },
			});
		}

		async function showPracticeAnswer(){
			const cur = practiceList[practiceIdx % Math.max(practiceList.length,1)];
			if (!cur) return;
			const target = document.getElementById('practiceTarget');
			target.innerHTML = '';
			const baseCh = normalizeHanChar(cur.ch);
			let opts = { width: 320, height: 320, padding: 12, showCharacter: true,
				strokeColor: '#22c55e', radicalColor: '#ef4444' };
			try {
				const cd = await fetchCharData(baseCh);
				opts = { ...opts, charData: cd };
			} catch {}
			practiceWriter = HanziWriter.create(target, baseCh, opts);
			practiceWriter.animateCharacter();
		}

		// 퀴즈
		let quizIndex = 0;
		let quizList = [];
		function startQuiz() {
			// Build quiz list similar to learn-mode cumulative behavior by group
			const grp = document.getElementById('groupFilter').value;
			let list = data;
			const m = String(grp || '').match(/^0*(\d+)$/);
			if (m) {
				const upTo = parseInt(m[1], 10);
				list = data.filter(x => {
					const mm = String(x.group || '').match(/^0*(\d+)$/);
					return mm && parseInt(mm[1], 10) <= upTo;
				});
			} else if (grp) {
				list = data.filter(x => (x.group || '') === grp);
			}
			const candidates = (list.length ? list : data).filter(x => (x.read || x.mean));
			quizList = shuffle(candidates);
			quizIndex = 0;
			showQuiz();
		}
		function showQuiz() {
			if (!quizList.length) {
				document.getElementById('quizQuestion').textContent = '-';
				document.getElementById('quizAnswer').value = '';
				const r = document.getElementById('quizResult');
				r.textContent = '퀴즈할 항목이 없습니다 (음/뜻이 있는 항목 없음)';
				r.className = 'result';
				return;
			}
			const q = quizList[quizIndex % quizList.length];
			document.getElementById('quizQuestion').textContent = q.ch;
			document.getElementById('quizAnswer').value = '';
			document.getElementById('quizResult').textContent = '';
		}
		function checkQuiz() {
			const q = quizList[quizIndex % quizList.length];
			const raw = document.getElementById('quizAnswer').value;
			const norm = (s) => (s || '').toString().trim().replace(/\s+/g, ' ');
			const a = norm(raw);
			const read = norm(q.read);
			const mean = norm(q.mean || '');
			// Accept: read, mean, or "mean read" (ex: "하늘 천")
			const combos = [];
			if (mean && read) combos.push(`${mean} ${read}`);
			const ok = a && (a === read || (mean && a === mean) || combos.includes(a));
			const r = document.getElementById('quizResult');
			r.textContent = ok ? `정답! (${mean ? mean + ' ' : ''}${read})` : `오답: ${mean ? mean + ' ' : ''}${read}`;
			r.className = 'result ' + (ok ? 'ok' : 'bad');
		}

		// 쓰기(추가)
		// 기존 수기 추가 UI는 제거되었습니다.

		// 백업/가져오기
		function doExport() {
			const blob = new Blob([JSON.stringify({ key: LS_KEY, items: data, exportedAt: new Date().toISOString() }, null, 2)], { type: 'application/json;charset=utf-8' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url; a.download = 'thousandChars_v1.json'; a.click();
			setTimeout(() => URL.revokeObjectURL(url), 500);
		}

		function viewJson(){
			const payload = { key: LS_KEY, items: data, exportedAt: new Date().toISOString() };
			const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json;charset=utf-8' });
			const url = URL.createObjectURL(blob);
			window.open(url, '_blank');
			setTimeout(() => URL.revokeObjectURL(url), 5 * 60 * 1000);
		}
		function doImport(file) {
			const name = (file.name || '').toLowerCase();
			const isExcel = /\.(xlsx|xls)$/.test(name);
			const isCsv = /\.(csv)$/.test(name);
			if (isExcel || isCsv) {
				const reader = new FileReader();
				reader.onload = (e) => {
					try {
						const dataArray = new Uint8Array(e.target.result);
						const wb = XLSX.read(dataArray, { type: 'array' });
						const sheet = wb.Sheets[wb.SheetNames[0]];
						// Prefer header-based parsing
						let rows = XLSX.utils.sheet_to_json(sheet, { defval: '' });
						if (!rows.length) {
							// Fallback: no headers, make rows from AOAs
							rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
							rows = rows.map(r => ({ ch: r[0] || '', read: r[1] || '', mean: r[2] || '', group: r[3] || '' }));
						}
						const norm = rows.map(r => ({
							ch: r.ch || r.char || r.hanja || r['한자'] || r['자'] || r['character'] || r['Character'] || r[0],
							read: r.read || r.kor || r.ko || r['음'] || r['독음'] || r['음/훈'] || r['훈음'] || r['reading'] || r['Reading'] || r[1] || '',
							mean: r.mean || r.desc || r['뜻'] || r['설명'] || r['훈'] || r['의미'] || r['meaning'] || r['Meaning'] || r[2] || '',
							group: r.group || r.grp || r['묶음'] || r['그룹'] || r['group'] || r['Group'] || r[3] || 'import',
						}))
						.filter(x => x.ch);
						if (!norm.length) throw new Error('엑셀/CSV에서 유효한 데이터가 없습니다. (열: 한자, 음/훈, 뜻, 묶음)');
						data = norm;
						try { localStorage.setItem(LS_LAST_IMPORT_KEY, JSON.stringify(data)); } catch {}
						saveData();
						renderLearn();
						rebuildGroupFilter();
						alert(`불러오기 완료: ${data.length}자`);
					} catch (err) {
						alert('엑셀/CSV 가져오기 실패: ' + err.message);
					}
				};
				if (isCsv) reader.readAsText(file, 'utf-8'); else reader.readAsArrayBuffer(file);
				return;
			}
			// JSON path (existing)
			const reader = new FileReader();
			reader.onload = () => {
				try {
					const json = JSON.parse(reader.result);
					// Accept either an array of items or an object with { key, items }
					const items = Array.isArray(json) ? json : (json.items || json.data || []);
					if (!Array.isArray(items)) throw new Error('잘못된 형식');
					// 기본 키 정규화
										data = items.map(x => ({ ch: x.ch || x.char || x.hanja, read: x.read || x.kor || x.ko || '', mean: x.mean || x.desc || '', group: x.group || x.grp || 'import' }))
											.filter(x => x.ch);
					try { localStorage.setItem(LS_LAST_IMPORT_KEY, JSON.stringify(data)); } catch {}
					saveData();
					renderLearn();
					rebuildGroupFilter();
					alert(`불러오기 완료: ${data.length}자`);
				} catch (e) {
					alert('가져오기 실패: ' + e.message);
				}
			};
			reader.readAsText(file, 'utf-8');
		}

		// 초기화
		function doReset() {
			if (!confirm('가장 최근 가져오기한 내용으로 초기화할까요?')) return;
			try {
				const last = localStorage.getItem(LS_LAST_IMPORT_KEY);
				if (last) {
					data = JSON.parse(last);
				} else {
					// fallback: seed
					data = seed;
				}
				saveData();
				renderLearn();
				rebuildGroupFilter();
				startQuiz();
				alert(`초기화 완료: ${data.length}자`);
			} catch (e) {
				alert('초기화 실패: ' + e.message);
			}
		}

		// 이벤트 바인딩
			document.addEventListener('DOMContentLoaded', async () => {
				await loadData();
			renderLearn();
			rebuildGroupFilter();
			startQuiz();

			document.getElementById('modeSelect').addEventListener('change', (e) => setMode(e.target.value));
			document.getElementById('search').addEventListener('input', doSearch);
			document.getElementById('groupFilter').addEventListener('change', () => { doSearch(); buildPracticeList(); startQuiz(); });
			document.getElementById('resetBtn').addEventListener('click', doReset);
			document.getElementById('exportBtn').addEventListener('click', doExport);
			document.getElementById('viewJsonBtn').addEventListener('click', viewJson);
			document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importFile').click());
			document.getElementById('importFile').addEventListener('change', (e) => { if (e.target.files[0]) { doImport(e.target.files[0]); setTimeout(() => { rebuildGroupFilter(); doSearch(); }, 100); } });

			// bulk paste feature removed

			document.getElementById('quizCheck').addEventListener('click', checkQuiz);
			document.getElementById('quizNext').addEventListener('click', () => { quizIndex++; showQuiz(); });
			document.getElementById('quizAnswer').addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); checkQuiz(); } });

			// 쓰기 상단 입력 폼 제거로 인한 이벤트 제거

			// 학습 카드 클릭 -> 필순 모달
			const learnGrid = document.getElementById('learnGrid');
			const strokeModal = document.getElementById('strokeModal');
			const strokeTarget = document.getElementById('strokeTarget');
			const strokeTitle = document.getElementById('strokeTitle');
			const strokeMeta = document.getElementById('strokeMeta');
			const strokeClose = document.getElementById('strokeClose');
			const strokeReplay = document.getElementById('strokeReplay');
			let writer = null;

			function openStroke(ch, read, mean){
				// 모달 표시
				const baseCh = normalizeHanChar(ch);
				strokeTitle.textContent = `필순: ${baseCh}`;
				strokeMeta.textContent = [read||'', mean||''].filter(Boolean).join(' · ');
				strokeTarget.innerHTML = '';
				strokeModal.classList.add('show');
				// Hanzi Writer 생성
				try {
					// charData를 직접 불러와(결손 보강 포함) 전달
					(async () => {
						let extraMeta = '';
						try {
							const cd = await fetchCharData(baseCh);
							writer = HanziWriter.create(strokeTarget, baseCh, {
								width: 280, height: 280, padding: 12, showCharacter: false,
								strokeColor: '#22c55e', radicalColor: '#ef4444',
								strokeAnimationSpeed: 1.2, delayBetweenStrokes: 150,
								charData: cd,
							});
							writer.animateCharacter();
						} catch(e) {
							// charData 로드 실패 시 기본 생성으로 폴백
							writer = HanziWriter.create(strokeTarget, baseCh, {
								width: 280, height: 280, padding: 12, showCharacter: false,
								strokeColor: '#22c55e', radicalColor: '#ef4444',
							});
							writer.animateCharacter();
						}
						// 부수 라벨 보완(색 분리 불가 시에도 텍스트로 안내)
						const meta = getRadicalMeta(baseCh);
						if (meta) {
							const label = `부수: ${meta.radical}${meta.name ? ' ('+meta.name+')' : ''}${meta.kangxi ? ' · 강희 '+meta.kangxi : ''}`;
							const parts = [read||'', mean||'', label].filter(Boolean);
							strokeMeta.textContent = parts.join(' · ');
						}
					})();
                } catch (e) {
                    strokeTarget.innerHTML = '<div style="padding:1rem; color:#f87171;">이 글자의 필순 데이터를 찾지 못했습니다.</div>';
                }
            }

            function closeStroke(){
                strokeModal.classList.remove('show');
            }

            learnGrid.addEventListener('click', (ev) => {
				const card = ev.target.closest('.card');
				if (!card) return;
				const idx = Number(card.getAttribute('data-idx'));
				const item = (data[idx]) || null;
				if (!item) return;
				openStroke(item.ch, item.read, item.mean);
			});
			strokeClose.addEventListener('click', closeStroke);
			strokeReplay.addEventListener('click', () => { if (writer) writer.animateCharacter(); });
			strokeModal.addEventListener('click', (e) => { if (e.target === strokeModal) closeStroke(); });

			// practice control events
			document.getElementById('pPrev').addEventListener('click', () => {
				if (!practiceList.length) return;
				if (practiceHistory.length > 1) {
					practiceHistory.pop();
					practiceIdx = practiceHistory[practiceHistory.length - 1];
					updatePracticeUI();
				} else {
					updatePracticeUI();
				}
			});
			document.getElementById('pNext').addEventListener('click', () => { if (practiceList.length) { setPracticeIdxRandom(true); }});
			document.getElementById('pStart').addEventListener('click', startPractice);
			document.getElementById('pReset').addEventListener('click', updatePracticeUI);
			document.getElementById('pShow').addEventListener('click', showPracticeAnswer);

			// initialize practice list initially
			buildPracticeList();
		});

		// bulk paste handler removed
	</script>
</body>
</html>

