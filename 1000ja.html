<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>천자문 연습</title>
	<style>
		:root {
			--bg: #0f172a; /* slate-900 */
			--panel: #111827; /* gray-900 */
			--muted: #94a3b8; /* slate-400 */
			--text: #e5e7eb; /* gray-200 */
			--accent: #22c55e; /* green-500 */
			--accent-2: #60a5fa; /* blue-400 */
			--danger: #f43f5e; /* rose-500 */
			--warn: #f59e0b; /* amber-500 */
		}
		* { box-sizing: border-box; }
		body { margin: 0; background: linear-gradient(120deg, #0b1020, #111a2f); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, sans-serif; }
		header { padding: 1rem 1.25rem; border-bottom: 1px solid #1f2937; position: sticky; top: 0; background: rgba(17,24,39,0.8); backdrop-filter: blur(6px); }
		header h1 { margin: 0; font-size: 1.125rem; }
		.container { max-width: 980px; margin: 0 auto; padding: 1rem 1.25rem; }
		.toolbar { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; }
		.toolbar select, .toolbar button, .toolbar input[type="text"] { background: #0b1220; color: var(--text); border: 1px solid #1f2937; padding: .5rem .75rem; border-radius: .5rem; }
		.toolbar button { cursor: pointer; }
		.toolbar button.primary { background: var(--accent); color: #052e13; border-color: transparent; font-weight: 600; }
		.toolbar label.lbl { color: var(--muted); font-size: .9rem; margin-left: .25rem; }
		.grid { display: grid; grid-template-columns: repeat(8, minmax(0, 1fr)); gap: .75rem; margin-top: 1rem; }
		/* Switch to block list when rendering per-row layout */
		.grid.rows-mode { display: block; }
		/* Numeric group selected -> 4 columns per row */
		.grid.cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
		/* Row of 4 cards + explanation to the right */
		.quad-row { display: grid; grid-template-columns: repeat(4, 0.375fr) 1.5fr; gap: .75rem; align-items: stretch; margin-bottom: .75rem; }
		.row-explain { background: #0b1220; border: 1px dashed #334155; color: var(--muted); border-radius: .5rem; padding: .6rem .7rem; font-size: .9rem; line-height: 1.5; }
		@media (max-width: 640px) { .quad-row { grid-template-columns: repeat(2, 1fr); } .row-explain { grid-column: 1 / -1; } }
		.card { background: #0b1220; border: 1px solid #1f2937; border-radius: .75rem; padding: .75rem; text-align: center; transition: transform .12s ease, border-color .12s ease; }
		.card:hover { transform: translateY(-2px); border-color: #334155; }
		.hanja { font-size: 28px; line-height: 1.2; }
		.hangeul { font-size: 12px; color: var(--muted); margin-top: .25rem; }
		.meta { margin-top: .35rem; font-size: 11px; color: #a1a1aa; }
		.mode { display: none; }
		.mode.active { display: block; }
		.panel { background: #0b1220; border: 1px solid #1f2937; border-radius: .75rem; padding: 1rem; margin-top: 1rem; }
		.row { display: grid; grid-template-columns: 1fr 1fr; gap: .75rem; align-items: center; }
		.row input, .row textarea { width: 100%; background: #0b1020; border: 1px solid #1f2937; color: var(--text); border-radius: .5rem; padding: .6rem .7rem; }
		.row label { font-size: .9rem; color: var(--muted); }
		.quiz { text-align: center; }
		.quiz .question { font-size: 36px; margin: .75rem 0; }
		.quiz .hint { color: var(--muted); font-size: .95rem; }
		.quiz input { margin-top: .5rem; font-size: 1rem; }
		.quiz .result { margin-top: .75rem; font-weight: 600; }
		.ok { color: var(--accent); }
		.bad { color: var(--danger); }
		.footer { color: var(--muted); font-size: .85rem; margin-top: 1rem; text-align: right; }

		/* Stroke-order modal */
		.modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 50; }
		.modal.show { display: flex; }
		.modal-content { width: min(92vw, 420px); background: #0b1220; border: 1px solid #1f2937; border-radius: 12px; box-shadow: 0 20px 60px rgba(0,0,0,0.35); }
		.modal-header { display: flex; align-items: center; justify-content: space-between; padding: .9rem 1rem; border-bottom: 1px solid #1f2937; }
		.modal-title { font-weight: 700; }
		.modal-body { padding: 1rem; display: grid; gap: .5rem; justify-items: center; }
		#strokeTarget { width: 280px; height: 280px; background: #0b1020; border: 1px dashed #334155; border-radius: .75rem; display: grid; place-items: center; }
		.modal-footer { padding: .9rem 1rem; display: flex; gap: .5rem; justify-content: flex-end; border-top: 1px solid #1f2937; }
		.btn { background: #0b1220; color: var(--text); border: 1px solid #334155; padding: .5rem .8rem; border-radius: .5rem; cursor: pointer; }
		.btn:hover { border-color: #475569; }
		.btn.primary { background: var(--accent); color: #052e13; border-color: transparent; font-weight: 700; }

		/* Bulk import modal */
		#bulkText { width: 100%; min-height: 180px; background: #0b1020; color: var(--text); border: 1px solid #1f2937; border-radius: .5rem; padding: .75rem; }
	</style>
    <script src="https://cdn.jsdelivr.net/npm/hanzi-writer@2.2/dist/hanzi-writer.min.js"></script>
</head>
<body>
	<header>
		<h1>천자문 연습 · 1000字</h1>
	</header>
	<div class="container">
		<div class="toolbar">
			<select id="modeSelect" title="모드 선택">
				<option value="learn">학습</option>
				<option value="quiz">퀴즈</option>
				<option value="write">쓰기</option>
			</select>
			<input type="text" id="search" placeholder="검색(한자/음/뜻)" />
			<label for="groupFilter" class="lbl">묶음:</label>
			<select id="groupFilter" title="묶음 선택">
				<option value="">전체 묶음</option>
			</select>
			<button id="shuffleBtn">섞기</button>
			<button id="resetBtn">초기화</button>
			<button id="exportBtn">백업</button>
			<input id="importFile" type="file" accept="application/json" style="display:none" />
			<button id="importBtn">가져오기</button>
			<button id="bulkBtn" class="primary" title="천자문 전체를 빠르게 붙여넣기로 등록">전체 붙여넣기</button>
			<span class="footer" id="countInfo"></span>
		</div>

		<!-- 학습 모드 -->
		<section id="mode-learn" class="mode active">
			<div class="grid" id="learnGrid"></div>
		</section>

		<!-- 퀴즈 모드 -->
		<section id="mode-quiz" class="mode">
			<div class="panel quiz">
				<div class="hint">한자를 보고 음(훈)을 쓰세요</div>
				<div class="question" id="quizQuestion">天</div>
				<input id="quizAnswer" type="text" placeholder="정답 입력" />
				<div>
					<button id="quizCheck" class="primary">정답 확인</button>
					<button id="quizNext">다음</button>
				</div>
				<div class="result" id="quizResult"></div>
			</div>
		</section>

		<!-- 쓰기 모드 -->
		<section id="mode-write" class="mode">
			<!-- Handwriting practice within current group -->
			<div class="panel" id="practicePanel">
				<div style="display:flex; justify-content:space-between; align-items:center; gap:.75rem; flex-wrap:wrap;">
					<div id="pRead" style="color: var(--muted); font-size:1rem;">천 / 하늘</div>
					<div class="practice-controls" style="display:flex; gap:.5rem;">
						<button id="pPrev">이전</button>
						<button id="pNext">다음</button>
						<button id="pStart" class="primary">쓰기 연습</button>
						<button id="pReset">초기화</button>
						<button id="pShow">다시 확인</button>
					</div>
				</div>
				<div id="practiceTarget" style="width:320px;height:320px;margin:.75rem auto; background:#ffffff; border:1px solid #e5e7eb; border-radius:.75rem;"></div>
				<div id="pHint" class="hint" style="text-align:center; color:var(--muted);">음/훈만 보고 흰 바탕에서 바로 써 보세요.</div>
			</div>
		</section>

	</div>

		<!-- Stroke-order Modal -->
		<div id="strokeModal" class="modal" aria-hidden="true">
			<div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="strokeTitle">
				<div class="modal-header">
					<div class="modal-title" id="strokeTitle">필순 보기</div>
					<button id="strokeClose" class="btn" aria-label="닫기">닫기</button>
				</div>
				<div class="modal-body">
					<div id="strokeTarget"></div>
					<div id="strokeMeta" style="color: var(--muted); font-size: .9rem;"></div>
				</div>
				<div class="modal-footer">
					<button id="strokeReplay" class="btn primary">다시 보기</button>
				</div>
			</div>
		</div>

			<!-- Bulk Paste Modal -->
			<div id="bulkModal" class="modal" aria-hidden="true">
				<div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="bulkTitle">
					<div class="modal-header">
						<div class="modal-title" id="bulkTitle">천자문 전체 붙여넣기</div>
						<button id="bulkClose" class="btn" aria-label="닫기">닫기</button>
					</div>
					<div class="modal-body" style="width:min(92vw, 620px)">
						<div style="font-size:.9rem; color:var(--muted); line-height:1.6; text-align:left;">
							천자문 1000자를 복사해 아래 상자에 붙여넣으세요. 공백/줄바꿈은 제거되며, 4자씩 한 묶음(001부터)으로 자동 그룹화됩니다.
						</div>
						<textarea id="bulkText" placeholder="예) 天地玄黃宇宙洪荒...  (1000자)"></textarea>
					</div>
					<div class="modal-footer">
						<button id="bulkReplace" class="btn" title="기존 데이터를 전체 교체">전체 교체</button>
						<button id="bulkMerge" class="btn primary" title="기존 데이터에 추가(중복 제거)">추가(중복 제거)</button>
					</div>
				</div>
			</div>

	<script>
		// 기본 데이터(시드). 이후 JSON으로 전체를 불러올 수 있음
		const seed = [
			{ ch: '天', read: '천', mean: '하늘', group: '001' },
			{ ch: '地', read: '지', mean: '땅', group: '001' },
			{ ch: '玄', read: '현', mean: '검다, 오묘하다', group: '001' },
			{ ch: '黃', read: '황', mean: '누르다', group: '001' },
			{ ch: '宇', read: '우', mean: '집, 공간', group: '002' },
			{ ch: '宙', read: '주', mean: '시간, 시공', group: '002' },
			{ ch: '洪', read: '홍', mean: '크다', group: '002' },
			{ ch: '荒', read: '황', mean: '거칠다', group: '002' },
		];

		const LS_KEY = 'thousandChars_v1';
		let data = [];

		function loadData() {
			try {
				const raw = localStorage.getItem(LS_KEY);
				data = raw ? JSON.parse(raw) : seed;
			} catch (e) {
				console.warn('localStorage 읽기 실패, seed 사용', e);
				data = seed;
			}
		}

		function saveData() { try { localStorage.setItem(LS_KEY, JSON.stringify(data)); } catch (e) { console.warn('저장 실패', e); } }

		function setMode(mode) {
			document.querySelectorAll('.mode').forEach(el => el.classList.remove('active'));
			document.getElementById('mode-' + mode).classList.add('active');
		}

		function renderLearn(list) {
			const el = document.getElementById('learnGrid');
			const currentList = (list || data);
			const grpVal = (document.getElementById('groupFilter')?.value || '').trim();
			const queryVal = (document.getElementById('search')?.value || '').trim();
			const matchNum = grpVal.match(/^0*(\d+)$/);

			// If numeric group selected and no query, render rows of 4 + explanation
			if (matchNum && !queryVal) {
				// Group explanations (extend as needed)
				const groupExplanations = {
					'001': '하늘과 땅이 나뉘면서 빛깔이 거무스름하고 누리끼리해졌다.',
					'002': '공간과 시간이 생기면서 큰 것과 거친 것이 만들어졌다.',
					'003': '해와 달이 떠올라 차면 기울어진다.',
				};
				// Build map group -> items
				const byGroup = new Map();
				currentList.forEach((x) => {
					const g = x.group || '';
					if (!byGroup.has(g)) byGroup.set(g, []);
					byGroup.get(g).push(x);
				});
				// Sort groups numerically ascending
				const groupKeys = Array.from(byGroup.keys()).sort((a, b) => Number(a) - Number(b));
				// Compose rows
				const rowsHtml = groupKeys.map(g => {
					const items = byGroup.get(g).slice(0, 4); // ensure 4 max
					const cards = items.map(it => {
						const idxGlobal = data.indexOf(it);
						const hint = [it.mean || '', it.read || ''].filter(Boolean).join(' ');
						return `
						<div class="card" data-idx="${idxGlobal}">
							<div class="hanja">${it.ch}</div>
							<div class="hangeul">${hint}</div>
						</div>`;
					}).join('');
					const base = groupExplanations[g] || '';
					return `<div class="quad-row">${cards}<div class="row-explain">${base}</div></div>`;
				}).join('');
				el.innerHTML = rowsHtml;
				document.getElementById('countInfo').textContent = `${currentList.length}자`;
				return;
			}

			// Default: flat card grid
			el.innerHTML = currentList.map((x) => {
				const idxGlobal = data.indexOf(x);
				const hint = [x.mean || '', x.read || ''].filter(Boolean).join(' ');
				return `
				<div class="card" data-idx="${idxGlobal}">
					<div class="hanja">${x.ch}</div>
					<div class="hangeul">${hint}</div>
				</div>`;
			}).join('');
			document.getElementById('countInfo').textContent = `${currentList.length}자`;
		}

		function shuffle(arr) {
			const a = [...arr];
			for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; }
			return a;
		}

		// 검색 + 그룹 필터
		function doSearch() {
			const q = document.getElementById('search').value.trim();
			const grp = document.getElementById('groupFilter').value;
			const learnGridEl = document.getElementById('learnGrid');
			let list = data;

			// Helper: parse numeric group like '001' -> 1; non-numeric returns null
			const parseGroupNum = (g) => {
				const m = String(g || '').match(/^0*(\d+)$/);
				return m ? parseInt(m[1], 10) : null;
			};

			const selectedNum = parseGroupNum(grp);
			if (selectedNum !== null) {
				// Cumulative: include all items with numeric group <= selected
				list = list.filter(x => {
					const gx = parseGroupNum(x.group);
					return gx !== null && gx <= selectedNum;
				});
				// Use rows-mode to render per-group rows with explanations
				if (!q) {
					learnGridEl.classList.add('rows-mode');
				} else {
					learnGridEl.classList.remove('rows-mode');
				}
			} else {
				// Equality filter for non-numeric groups (e.g., 'custom')
				if (grp) list = list.filter(x => (x.group || '') === grp);
				// Back to default grid
				learnGridEl.classList.remove('rows-mode');
			}

			if (q) {
				const re = new RegExp(q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
				list = list.filter(x => re.test(x.ch) || re.test(x.read) || re.test(x.mean || ''));
			}
			renderLearn(list);
		}

		function rebuildGroupFilter() {
			const sel = document.getElementById('groupFilter');
			const current = sel.value;
			const groups = Array.from(new Set(data.map(x => x.group).filter(Boolean))).sort();
			sel.innerHTML = '<option value="">전체 묶음</option>' + groups.map(g => `<option value="${g}">${g}</option>`).join('');
			if (current && groups.includes(current)) sel.value = current;
		}

		// Practice (handwriting) helpers
		let practiceList = [];
		let practiceIdx = 0;
		let practiceWriter = null;
		// Initialize a freehand drawing canvas inside #practiceTarget
		function initFreehandCanvas(){
			const target = document.getElementById('practiceTarget');
			target.innerHTML = '';
			const size = 320;
			const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
			const canvas = document.createElement('canvas');
			canvas.style.width = size + 'px';
			canvas.style.height = size + 'px';
			canvas.width = size * dpr;
			canvas.height = size * dpr;
			target.appendChild(canvas);
			const ctx = canvas.getContext('2d');
			ctx.scale(dpr, dpr);
			ctx.lineWidth = 3;
			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';
			ctx.strokeStyle = '#111827'; // dark ink on white
			let drawing = false;
			let lastX = 0, lastY = 0;
			const getPos = (e) => {
				const rect = canvas.getBoundingClientRect();
				const x = (e.clientX - rect.left);
				const y = (e.clientY - rect.top);
				return { x, y };
			};
			canvas.addEventListener('pointerdown', (e) => {
				canvas.setPointerCapture(e.pointerId);
				e.preventDefault();
				const p = getPos(e);
				drawing = true;
				lastX = p.x; lastY = p.y;
				ctx.beginPath();
				ctx.moveTo(lastX, lastY);
			});
			canvas.addEventListener('pointermove', (e) => {
				if (!drawing) return;
				e.preventDefault();
				const p = getPos(e);
				ctx.lineTo(p.x, p.y);
				ctx.stroke();
				lastX = p.x; lastY = p.y;
			});
			const endDraw = (e) => { if (!drawing) return; e.preventDefault(); drawing = false; };
			canvas.addEventListener('pointerup', endDraw);
			canvas.addEventListener('pointercancel', endDraw);
			canvas.addEventListener('pointerleave', endDraw);
		}
		function buildPracticeList(){
			const grp = document.getElementById('groupFilter').value;
			if (!grp) {
				practiceList = data.slice(0, 16); // default: first few
			} else {
				// In write mode: practice only the selected group (e.g., 002 → that group's 4 chars)
				practiceList = data.filter(x => (x.group || '') === grp).slice(0, 4);
			}
			practiceIdx = 0;
			updatePracticeUI();
		}

		function updatePracticeUI(){
			const cur = practiceList[practiceIdx % Math.max(practiceList.length,1)];
			document.getElementById('pRead').textContent = cur ? [cur.mean || '', cur.read || ''].filter(Boolean).join(' ') : '';
			// Reset view to freehand canvas (pre-practice)
			practiceWriter = null;
			initFreehandCanvas();
		}

		function startPractice(){
			const cur = practiceList[practiceIdx % Math.max(practiceList.length,1)];
			if (!cur) return;
			const target = document.getElementById('practiceTarget');
			target.innerHTML = '';
			practiceWriter = HanziWriter.create(target, cur.ch, {
				width: 320, height: 320, padding: 12, showCharacter: false,
				strokeColor: '#22c55e', radicalColor: '#ef4444',
				strokeAnimationSpeed: 1.1, delayBetweenStrokes: 150,
			});
			practiceWriter.quiz({
				showHintAfterMisses: 2,
				onComplete: () => { /* optional: toast */ },
			});
		}

		function showPracticeAnswer(){
			const cur = practiceList[practiceIdx % Math.max(practiceList.length,1)];
			if (!cur) return;
			const target = document.getElementById('practiceTarget');
			target.innerHTML = '';
			practiceWriter = HanziWriter.create(target, cur.ch, {
				width: 320, height: 320, padding: 12, showCharacter: true,
				strokeColor: '#22c55e', radicalColor: '#ef4444',
			});
			practiceWriter.animateCharacter();
		}

		// 퀴즈
		let quizIndex = 0;
		let quizList = [];
		function startQuiz() {
			// Build quiz list similar to learn-mode cumulative behavior by group
			const grp = document.getElementById('groupFilter').value;
			let list = data;
			const m = String(grp || '').match(/^0*(\d+)$/);
			if (m) {
				const upTo = parseInt(m[1], 10);
				list = data.filter(x => {
					const mm = String(x.group || '').match(/^0*(\d+)$/);
					return mm && parseInt(mm[1], 10) <= upTo;
				});
			} else if (grp) {
				list = data.filter(x => (x.group || '') === grp);
			}
			quizList = shuffle(list.length ? list : data);
			quizIndex = 0;
			showQuiz();
		}
		function showQuiz() {
			if (!quizList.length) { startQuiz(); return; }
			const q = quizList[quizIndex % quizList.length];
			document.getElementById('quizQuestion').textContent = q.ch;
			document.getElementById('quizAnswer').value = '';
			document.getElementById('quizResult').textContent = '';
		}
		function checkQuiz() {
			const q = quizList[quizIndex % quizList.length];
			const a = document.getElementById('quizAnswer').value.trim();
			const ok = a && (a === q.read || (q.mean && a === q.mean));
			const r = document.getElementById('quizResult');
			r.textContent = ok ? `정답! (${q.read}${q.mean ? ' / ' + q.mean : ''})` : `오답: ${q.read}${q.mean ? ' / ' + q.mean : ''}`;
			r.className = 'result ' + (ok ? 'ok' : 'bad');
		}

		// 쓰기(추가)
		// 기존 수기 추가 UI는 제거되었습니다.

		// 백업/가져오기
		function doExport() {
			const blob = new Blob([JSON.stringify({ items: data, exportedAt: new Date().toISOString() }, null, 2)], { type: 'application/json;charset=utf-8' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url; a.download = '1000ja-backup.json'; a.click();
			setTimeout(() => URL.revokeObjectURL(url), 500);
		}
		function doImport(file) {
			const reader = new FileReader();
			reader.onload = () => {
				try {
					const json = JSON.parse(reader.result);
					const items = json.items || json.data || json || [];
					if (!Array.isArray(items)) throw new Error('잘못된 형식');
					// 기본 키 정규화
					data = items.map(x => ({ ch: x.ch || x.char || x.hanja, read: x.read || x.kor || x.ko || '', mean: x.mean || x.desc || '', group: x.group || x.grp || 'import' })).filter(x => x.ch && x.read);
					saveData();
					renderLearn();
					alert(`불러오기 완료: ${data.length}자`);
				} catch (e) {
					alert('가져오기 실패: ' + e.message);
				}
			};
			reader.readAsText(file, 'utf-8');
		}

		// 초기화
		function doReset() { if (confirm('저장된 학습 데이터를 초기화할까요?')) { localStorage.removeItem(LS_KEY); loadData(); renderLearn(); startQuiz(); } }

		// 이벤트 바인딩
			document.addEventListener('DOMContentLoaded', () => {
			loadData();
			renderLearn();
			rebuildGroupFilter();
			startQuiz();

			document.getElementById('modeSelect').addEventListener('change', (e) => setMode(e.target.value));
			document.getElementById('search').addEventListener('input', doSearch);
			document.getElementById('groupFilter').addEventListener('change', () => { doSearch(); buildPracticeList(); startQuiz(); });
			document.getElementById('shuffleBtn').addEventListener('click', () => { data = shuffle(data); saveData(); renderLearn(); startQuiz(); });
			document.getElementById('resetBtn').addEventListener('click', doReset);
			document.getElementById('exportBtn').addEventListener('click', doExport);
			document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importFile').click());
			document.getElementById('importFile').addEventListener('change', (e) => { if (e.target.files[0]) { doImport(e.target.files[0]); setTimeout(() => { rebuildGroupFilter(); doSearch(); }, 100); } });

			// Bulk paste modal events
			const bulkModal = document.getElementById('bulkModal');
			document.getElementById('bulkBtn').addEventListener('click', () => { bulkModal.classList.add('show'); });
			document.getElementById('bulkClose').addEventListener('click', () => { bulkModal.classList.remove('show'); });
			bulkModal.addEventListener('click', (e) => { if (e.target === bulkModal) bulkModal.classList.remove('show'); });
			document.getElementById('bulkReplace').addEventListener('click', () => handleBulk('replace'));
			document.getElementById('bulkMerge').addEventListener('click', () => handleBulk('merge'));

			document.getElementById('quizCheck').addEventListener('click', checkQuiz);
			document.getElementById('quizNext').addEventListener('click', () => { quizIndex++; showQuiz(); });
			document.getElementById('quizAnswer').addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); checkQuiz(); } });

			// 쓰기 상단 입력 폼 제거로 인한 이벤트 제거

			// 학습 카드 클릭 -> 필순 모달
			const learnGrid = document.getElementById('learnGrid');
			const strokeModal = document.getElementById('strokeModal');
			const strokeTarget = document.getElementById('strokeTarget');
			const strokeTitle = document.getElementById('strokeTitle');
			const strokeMeta = document.getElementById('strokeMeta');
			const strokeClose = document.getElementById('strokeClose');
			const strokeReplay = document.getElementById('strokeReplay');
			let writer = null;

			function openStroke(ch, read, mean){
				// 모달 표시
				strokeTitle.textContent = `필순: ${ch}`;
				strokeMeta.textContent = [read||'', mean||''].filter(Boolean).join(' · ');
				strokeTarget.innerHTML = '';
				strokeModal.classList.add('show');
				// Hanzi Writer 생성
				try {
					writer = HanziWriter.create(strokeTarget, ch, {
						width: 280,
						height: 280,
						padding: 12,
						showCharacter: false,
						strokeColor: '#22c55e',
						radicalColor: '#ef4444',
						strokeAnimationSpeed: 1.2,
						delayBetweenStrokes: 150,
					});
					writer.animateCharacter();
				} catch (e) {
					strokeTarget.innerHTML = '<div style="padding:1rem; color:#f87171;">이 글자의 필순 데이터를 찾지 못했습니다.</div>';
				}
			}

			function closeStroke(){
				strokeModal.classList.remove('show');
			}

			learnGrid.addEventListener('click', (ev) => {
				const card = ev.target.closest('.card');
				if (!card) return;
				const idx = Number(card.getAttribute('data-idx'));
				const item = (data[idx]) || null;
				if (!item) return;
				openStroke(item.ch, item.read, item.mean);
			});
			strokeClose.addEventListener('click', closeStroke);
			strokeReplay.addEventListener('click', () => { if (writer) writer.animateCharacter(); });
			strokeModal.addEventListener('click', (e) => { if (e.target === strokeModal) closeStroke(); });

			// practice control events
			document.getElementById('pPrev').addEventListener('click', () => { if (practiceList.length) { practiceIdx = (practiceIdx - 1 + practiceList.length) % practiceList.length; updatePracticeUI(); }});
			document.getElementById('pNext').addEventListener('click', () => { if (practiceList.length) { practiceIdx = (practiceIdx + 1) % practiceList.length; updatePracticeUI(); }});
			document.getElementById('pStart').addEventListener('click', startPractice);
			document.getElementById('pReset').addEventListener('click', updatePracticeUI);
			document.getElementById('pShow').addEventListener('click', showPracticeAnswer);

			// initialize practice list initially
			buildPracticeList();
		});

		function handleBulk(mode){
			const raw = document.getElementById('bulkText').value;
			if (!raw || raw.trim().length < 4) { alert('문자를 붙여넣어 주세요.'); return; }
			// 공백/제어문자 제거 후 한자만 필터링
			const cleaned = raw.replace(/\s+/g, '');
			const onlyHan = Array.from(cleaned).filter(ch => /\p{Script=Han}/u.test(ch));
			if (onlyHan.length < 4) { alert('유효한 입력이 아닙니다. 한자(漢字)만 붙여넣어 주세요.'); return; }
			const built = onlyHan.map((ch, i) => ({ ch, read: '', mean: '', group: String(Math.floor(i/4)+1).padStart(3,'0') }));
			if (mode === 'replace') {
				data = built;
			} else {
				// merge: 문자 기준 중복 제거
				const existingSet = new Set(data.map(x => x.ch));
				const toAdd = built.filter(x => !existingSet.has(x.ch));
				data = data.concat(toAdd);
			}
			saveData();
			rebuildGroupFilter();
			doSearch();
			alert(`등록 완료: 총 ${data.length}자, 그룹 ${new Set(data.map(x=>x.group).filter(Boolean)).size}개`);
			document.getElementById('bulkText').value = '';
			document.getElementById('bulkModal').classList.remove('show');
		}
	</script>
</body>
</html>

